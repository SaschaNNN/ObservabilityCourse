input {
  beats {
    port => 5044
  }
}

filter {
  grok {
    match => {
      "message" => "%{TIME:timestamp} %{WORD:ssh_host} %{WORD:tag}\[%{NUMBER}\]: %{GREEDYDATA:msg}"
    }
  }
  if "Invalid user" in [msg] {
    grok {
      match => {
        "msg" => "Invalid user %{WORD:ssh_user} from %{IPV4:ssh_src_ip} port %{NUMBER:ssh_src_port}"
      }
    }
    mutate {
      replace => { "auth_result" => "failure" }
      add_tag => [ "failure" ]
    }
  }
  if "Accepted publickey" in [msg] {
    grok {
      match => {
        "msg" => "Accepted publickey for %{WORD:ssh_user} from %{IPV4:ssh_src_ip} port %{NUMBER:ssh_src_port} %{WORD:ssh_version}: %{WORD:encrypt_algorithm} %{WORD:encrypt_key}:%{GREEDYDATA:public_key}"
      }
    }
    mutate {
      replace => { "auth_result" => "success" }
      add_tag => [ "suscess" ]
    }
  }
  if "Unable to negotiate" in [msg] {
    grok {
      match => {
        "msg" => "Unable to negotiate with %{IPV4:ssh_src_ip} port %{NUMBER:ssh_src_port}: no matching host key type found. Their offer: %{GREEDYDATA:encrypt_algorythm_proposals} \[%{WORD:auth}\]"
      }
    }
    mutate {
      replace => { "auth_result" => "failure" }
      add_tag => [ "failure" ]
    }
  }
}

output {
  elasticsearch {
    hosts => ["https://localhost:9200"]
    #index => "logstash-%{+YYYY.MM.dd}"
    index => "%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}"
    user => "elastic"
    password => "Ps7zec6JBMwWV-Pzz9tH"
    cacert => "/home/ubuntu/http_ca.crt"
  }
}
